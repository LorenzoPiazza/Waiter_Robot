/*
 * SPRINT_0
 * Modello derivante dall'analisi del Problema fatta nell'overview iniziale (sprint0).
 */
 
 System tearoom_covid19

 /* Messaggi */
 
 /*--------waiter <-> smartbell -------- */
 Request enterRequest : enterRequest(CID)
 Reply 	 answer 	  : answer(TIME)	/* TIME = 0 significa che la richiesta del cliente viene accettata e il waiter sta arrivando ad accoglierlo
  										 * altrimenti TIME rappresenta il maxWaitingTime da aspettare perchè la sala è piena
  										 */
 
 /*--------waiter <-> barman ----------- */
 Dispatch order 	 : order(CID, TEA)
 Dispatch orderReady : orderReady(CID, TEA)
 
 /*--------waiter <-> client ----------- */ /* UTILI AI FINI DELLA SIMULAZIONE */
 Dispatch readyToPay   : readyToPay(CID)
 Dispatch readyToOrder : readyToOrder(CID)
 
 /*--------client <-> smartbell -------- */	/* UTILI AI FINI DELLA SIMULAZIONE */
 Request ring 		  : ring(N)
 Reply waiterResponse : waiterResponse(CID, TIME)
 Reply refused 		  : refused(CAUSE)
 
 
 Context ctxTearoom ip [ host='localhost' port=8000 ]
 
 /* Attori */
 QActor waiter context ctxTearoom {
 	[# 
 		var nTableAvailable = 2
 	 	val MaxStayTime = 10000
 	 #]
 	
 	State s0 initial{
 		discardMsg Off
 		println("&&&&& waiter | starts &&&&&")
 		delay 3000
 	}
 	Goto waitForRequest
 	
 	State waitForRequest{
 		println("&&&&& waiter | waiting for any kind of requests... &&&&&")
 	}
 	Transition t0 	whenTime 	 12000 		  -> rest
 					whenRequest  enterRequest -> evaluateEntrance
 					whenMsg  	 readyToOrder -> takeOrder
 					whenMsg		 orderReady	  -> serveClient
 					whenMsg  	 readyToPay   -> collectPayment
 					
 	State evaluateEntrance{
 		onMsg( enterRequest : enterRequest(CID) ){
 			println("&&&&& waiter | evaluating the enterRequest of the client ID = ${payloadArg(0)} ")
 			//TODO: Check the availability of the teatable in state tableclean
 		}
 		delay 3000
 	}
 	Goto accept if [# nTableAvailable >= 1 #] else inform
 	
 	State accept{
 		println("&&&&& waiter | EnterRequest accepted. &&&&&")
 		//TODO: Occupy one teatable in state tableclean with the current client_id
 		replyTo enterRequest with answer : answer(0)
 		delay 3000
 	}
 	Goto reachEntranceDoor
 	
 	State reachEntranceDoor{
 		println("&&&&& waiter | I'm going to the entrance door... &&&&&")
 		delay 3000
 	}
 	Goto convoyToTable
 	
 	State convoyToTable{
 		println("&&&&& waiter | Follow me to the table... &&&&&")
 		//TODO: When the client reach the table we start the maxStayTime countdown for that client
 		delay 3000	
 	}
 	Goto waitForRequest
 	
 	State inform{
 		println("&&&&& waiter | Sorry, at the moment the TeaRoom is full. Retry in ${maxStayTime/1000} seconds &&&&&")
 		//TODO: Occupy one teatable in state tableclean with the current client_id
 		replyTo enterRequest with answer : answer($MaxStayTime)
 		delay 3000
 	}
 	Goto waitForRequest
 	
 	State takeOrder{
 		onMsg(readyToOrder : readyToOrder (CID)){
 			println("&&&&& waiter | I'm taking the order of client ${payloadArg(0)} and transmitting it to barman .&&&&&")
 			forward barman -m order : order( $payloadArg(0), LemonTea)
 			delay 3000  
 		}
 	}
 	Goto waitForRequest
 	
 	State serveClient{
 		onMsg(orderReady : orderReady (CID, TEA)){
 			println("&&&&& waiter | I'm going to barman, taking the ${payloadArg(1)} for the client ${payloadArg(0)} and serving it at the table.&&&&&")
 			delay 3000
 		}
 	}
 	Goto waitForRequest
 	
 	State collectPayment{
 		printCurrentMessage
 		println("&&&&& waiter | I'm going to the table of client ${payloadArg(0)} and collect the payment.&&&&&")
 		delay 3000
 	}
 	Goto convoyToExit
 	
 	State convoyToExit{
 		println("&&&&& waiter | Follow me to the exit door...Bye,Bye! &&&&&")
 		delay 3000
 	}
 	Goto clean
 	
 	State clean{
 		println("&&&&& waiter | I'm cleaning the table! &&&&&")
 		delay 3000
 	}
 	Goto waitForRequest
 		
 	State rest{
 		println("&&&&& waiter | I'm going to return to home and relax. &&&&&")
 	}
 	Transition t0 	whenRequest  enterRequest -> evaluateEntrance
 					whenMsg  	 readyToOrder -> takeOrder
 					whenMsg		 orderReady	  -> serveClient
 					whenMsg  	 readyToPay   -> collectPayment			
 }
 
 QActor smartbell context ctxTearoom{
 	[#
 		var currentBodyTemperature = 36
 		var currentClientID = 1
 		var timeToWait : Int
 			
 	#]
 	 State s0 initial{
 		println("&&&&& smartbell | starts &&&&&")
 	}
 	Goto listening
 	
 	State listening{
 		println("&&&&& smartbell | listening to ringing... &&&&&")
 	}
 	Transition t0 	whenRequest ring -> checkClient
 	
 	State checkClient{
 		onMsg(ring : ring(N) ){
 			println("&&&&& smartbell | DRIIN !! Let's control the body temperature... &&&&&")
 			[# readLine() #]
 			//TODO: simulate a temperature rilevation	
 		}
 	}
 	Goto doEnterReq if [# currentBodyTemperature < 37.5 #] else refuseClient
 	
 	State doEnterReq{
 		println("&&&&& smartbell | Forward the entranceRequest for client $currentClientID. &&&&&")
 		request waiter -m enterRequest : enterRequest(currentClientID)
 		[# currentClientID ++ #]
 	}
 	Transition t0 whenReply answer -> showAnswer
 	
 	State showAnswer{
 		onMsg(answer : answer (TIME)){
 			[# timeToWait = payloadArg(0).toString().toInt() #]
 			if [# timeToWait == 0 #] {
 				println("&&&&& smartbell | Welcome! The waiter is coming to get you. &&&&&")
 				replyTo ring with waiterResponse : waiterResponse(currentClientID, timeToWait)		//Ai fini della simulazione, diamo una risposta al cliente
 			}else{
 				println("&&&&& smartbell | The teaRoom is full! Retry in ${timeToWait/1000} seconds. &&&&&")
 				replyTo ring with waiterResponse : waiterResponse(currentClientID, timeToWait)		//Ai fini della simulazione, diamo una risposta al cliente
 				//WARNING: When this client will return the smartbell will assign him/her a new ID.
 			}
 		} 
 	}
 	Goto listening
 	
 	State refuseClient{
 		println("&&&&& smartbell | I'm sorry! You're not allowed to enter cause your body temperature is high. &&&&&")
 		replyTo ring with refused : refused(HighBodyTemperature)
 	}
 	Goto listening
 }
 
 
 QActor barman context ctxTearoom{
 	 State s0 initial{
 		println("&&&&& barman | starts &&&&&")
 	}
 	Goto waitForOrder
 	
 	State waitForOrder{
 		println("&&&&& barman | waiting for orders... &&&&&")
 	}
 	Transition t0 whenMsg order -> prepare
 	
 	State prepare{
 		onMsg(order : order(CID, TEA)){
 			println("&&&&& barman | preparing the order of ${payloadArg(1)} for client ${payloadArg(0)}. &&&&&")
 	
 		}
 	}
 	Goto waitForOrder
 }
 
 QActor client_simulator context ctxTearoom{
 	[#
 		var nClientSimulated = 0
 		val totalClient = 1	
 		var timeToWait : Int
 	#] 
 	State s0 initial{
 		println("&&&&& CLIENT SIMULATOR | starts &&&&&")
 	}
 	Goto ringBell
 	
 	State ringBell{
 		[# readLine() #]
 		println("&&&&& NEW CLIENT: RING THE SMARTBELL &&&&&")
 		[# nClientSimulated ++ #]
 		request smartbell -m ring : ring(0) 
 	}
 	Transition t0 whenReply waiterResponse ->  	checkAnswer
 				  whenReply refused 	   ->	refused
 	
 	State refused{
 		onMsg(refused : refused(CAUSE)){
 			println("&&&&& CLIENT | I've been refused for this cause: ${payloadArg(0)}. &&&&&")
 		}
 	}
 	Goto ringBell if [# nClientSimulated <= totalClient #] else end
 	
 	State checkAnswer{
 		onMsg(waiterResponse : waiterResponse(CID, TIME)){
 			[# timeToWait = payloadArg(1).toInt() #]
 			if [# timeToWait == 0 #] {	//Il cliente è stato accettato
 				//TODO: Continue the client simulation, with order, payment ecc...
 				delay 5000 				
 			}
 			else{
 				println("&&&&& CLIENT ${payloadArg(1)} | Maybe I'll return later. &&&&&")
 			}
 		}
 	}
 	Goto ringBell if [# nClientSimulated <= totalClient #] else end
 	
 	State end{
 		println("&&&&& All clients simulated, BYE! &&&&&")
 		terminate 0
 	}
 		
 }